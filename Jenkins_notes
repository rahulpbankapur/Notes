how we can configure ec2, docker and k8s pod as a jenkins agent explain with complete explanation and steps and live example

Great! Let's walk through how to configure three different Jenkins agent types:

EC2 instance as an agent

Docker container as an agent

Kubernetes pod as an agent

We'll go step-by-step for each, with explanations and practical examples.

🖥️ 1. EC2 Instance as Jenkins Agent
🔧 Use Case:
You want to run builds on a dedicated VM (like Linux EC2) for more control or persistent environments.

✅ Steps:
1. Launch EC2 Instance:
OS: Amazon Linux 2 or Ubuntu

Install Java:

bash
Copy
Edit
sudo yum install java-11-amazon-corretto -y     # For Amazon Linux
Add a jenkins user (optional):

bash
Copy
Edit
sudo adduser jenkins
sudo passwd jenkins
2. Configure SSH:
Generate SSH key pair on Jenkins master:

bash
Copy
Edit
ssh-keygen -t rsa
Copy the public key to the EC2 instance:

bash
Copy
Edit
ssh-copy-id jenkins@<ec2-public-ip>
3. In Jenkins:
Go to Manage Jenkins → Nodes → New Node

Type: Permanent Agent

Configuration:

Remote root directory: /home/jenkins

Labels: ec2

Launch method: Launch agent via SSH

Add SSH credentials

Host Key Verification Strategy: Non-verifying for testing

4. Test:
Jenkins will SSH to EC2 and connect.

Add agent { label 'ec2' } in a pipeline job.

🐳 2. Docker Container as Jenkins Agent
🔧 Use Case:
Run builds in isolated containers, so each job starts in a clean environment.

✅ Steps:
1. Install Docker on Jenkins Server:
bash
Copy
Edit
sudo apt install docker.io -y
sudo usermod -aG docker jenkins
Restart Jenkins to apply group changes.

2. Install Docker Plugin in Jenkins:
Manage Jenkins → Plugin Manager → Install "Docker Pipeline" plugin

3. Configure Docker Cloud:
Manage Jenkins → Manage Nodes and Clouds → Configure Clouds

Add Docker cloud with:

Docker Host URI: unix:///var/run/docker.sock

Test connection

4. Define Docker Agent in a Pipeline:
groovy
Copy
Edit
pipeline {
  agent {
    docker {
      image 'maven:3.8.1-jdk-11'
      label 'docker'
    }
  }
  stages {
    stage('Build') {
      steps {
        sh 'mvn --version'
      }
    }
  }
}
💡 What Happens:
Jenkins spins up a new container with Maven

Runs the build

Container is removed after the job ends

☸️ 3. Kubernetes Pod as Jenkins Agent
🔧 Use Case:
Run Jenkins builds on-demand as pods in Kubernetes. Great for scalability and cloud-native pipelines.

✅ Prerequisites:
A running Kubernetes cluster (EKS, GKE, Minikube, etc.)

Jenkins installed (either on the cluster or elsewhere)

kubectl access

✅ Steps:
1. Install Kubernetes Plugin in Jenkins:
Manage Jenkins → Plugin Manager → Install "Kubernetes" plugin

2. Create a Service Account in Kubernetes:
yaml
Copy
Edit
apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins-agent
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: jenkins
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: ServiceAccount
  name: jenkins-agent
  namespace: default
Apply it:

bash
Copy
Edit
kubectl apply -f jenkins-agent-rbac.yaml
3. Configure Jenkins Kubernetes Cloud:
Go to Manage Jenkins → Configure System

Under Cloud, add Kubernetes:

Kubernetes URL: (leave empty if Jenkins runs inside the cluster)

Kubernetes namespace: default

Credentials: Kubernetes Service Account

Test Connection

4. Configure Pod Template:
Container template:

Name: jnlp

Docker image: jenkins/inbound-agent

Command to run: leave blank

Arguments: leave default

5. Define Agent in a Pipeline:
groovy
Copy
Edit
pipeline {
  agent {
    kubernetes {
      label 'k8s-agent'
      defaultContainer 'jnlp'
      yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: maven
    image: maven:3.8.1-jdk-11
    command:
    - cat
    tty: true
"""
    }
  }
  stages {
    stage('Build') {
      steps {
        container('maven') {
          sh 'mvn --version'
        }
      }
    }
  }
}
📊 Summary Comparison
Agent Type	Environment	Best For	Setup Effort
EC2	Static VM	Persistent, flexible builds	Medium
Docker	Local container	Clean, isolated builds	Low
Kubernetes	Cluster	Scalable, ephemeral builds	High
